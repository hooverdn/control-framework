(function (three_js,Detector,objectControls) {
'use strict';

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/*
 * (MIT License)
 * Copyright 2017,2018  Douglas N. Hoover
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 *  An way to group two Make meshes for two geometries with two different, but fixed,
 *  materials and put them together in a group.  Draw lines of different but fixed
 */

var DualPair = function () {

	/**
  *  Make primary and dual meshes with associated edgelines and put
  *  them in groups so that primary and dual meshes, with their
  *  edges, can be easily manipulated separately and together.
  */
	function DualPair(primaryGeom, dualGeom) {
		classCallCheck(this, DualPair);


		var primaryMaterial = new three_js.MeshLambertMaterial({

			color: 0x156289,
			emissive: 0x072534,
			side: three_js.FrontSide,
			flatShading: three_js.FlatShading,
			transparent: false

		});

		var dualMaterial = new three_js.MeshLambertMaterial({

			color: 0xea9d76,
			emissive: 0x52d444,
			side: three_js.FrontSide,
			flatShading: three_js.FlatShading,
			transparent: false

		});

		var primaryMesh = new three_js.Mesh(primaryGeom, primaryMaterial);
		var primaryLines = makeEdgeLines(primaryGeom, 0xffff00);
		this.primaryGroup = new three_js.Group();
		this.primaryGroup.add(primaryMesh);
		this.primaryGroup.add(primaryLines);

		var dualMesh = new three_js.Mesh(dualGeom, dualMaterial);
		var dualLines = makeEdgeLines(dualGeom, 0xff00ff);
		this.dualGroup = new three_js.Group();
		this.dualGroup.add(dualMesh);
		this.dualGroup.add(dualLines);

		this.group = new three_js.Group();
		this.group.add(this.primaryGroup);
		this.group.add(this.dualGroup);

		function makeEdgeLines(geometry, color) {

			var edges = new three_js.EdgesGeometry(geometry);
			var lineMaterial = new three_js.LineBasicMaterial({ color: color });
			return new three_js.LineSegments(edges, lineMaterial);
		}
	}

	/**
  *  Set the position of the group containing the meshes and edges
  *  represented by this DualPair.
  */


	createClass(DualPair, [{
		key: 'setPosition',
		value: function setPosition(x, y, z) {

			this.group.position.set(x, y, z);
		}

		/**
   *  Add this object&#8217;s group to the given <code>Object3D</code>.
   *
   *  @param {THREE.Object3D} Add the group represented by this
   *  DualPair to this <code>Object3D</code>, which will typically be
   *  a scene or a group.
   */

	}, {
		key: 'addTo',
		value: function addTo(object) {

			object.add(this.group);
		}

		/**
   *  Separately set the scale of the meshes, with their edge lines,
   *  made from the primary and dual geometries.
   */

	}, {
		key: 'setScale',
		value: function setScale(primaryScale, dualScale) {

			this.primaryGroup.scale.set(primaryScale, primaryScale, primaryScale);
			this.dualGroup.scale.set(dualScale, dualScale, dualScale);
		}

		/**
   *  Set the rotation coordinates of the primary mesh.
   */

	}, {
		key: 'rotatePrimary',
		value: function rotatePrimary(x, y, z) {

			this.primaryGroup.rotation.set(x, y, z);
		}

		/**
   *  Set the rotation coordinates of the dual mesh.
   */

	}, {
		key: 'rotateDual',
		value: function rotateDual(x, y, z) {

			this.dualGroup.rotation.set(x, y, z);
		}
	}]);
	return DualPair;
}();

/*
 * (MIT License)
 * Copyright 2017,2018  Douglas N. Hoover
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

var noflags = objectControls.ControlManager.noflags;
var fov = 28;
var origin = new three_js.Vector3(0, 0, 0);

function init() {

	var clock = new three_js.Clock();
	var scene = new three_js.Scene();
	scene.background = new three_js.Color(0x3f3f3f);
	//const text = document.getElementById( 'text' );
	var container = document.getElementById('webgl');
	var height = window.innerHeight; // - text.clientHeight;
	var width = window.innerWidth;

	var cameraGroup = new three_js.Group();
	cameraGroup.position.z = 70;
	scene.add(cameraGroup);
	var camera = void 0;

	if (width > height) {

		camera = new three_js.PerspectiveCamera(Math.max(fov, 48 * height / width), width / height, 0.1, 200);
	} else {

		camera = new three_js.PerspectiveCamera(Math.max(fov * height / width, 48), width / height, 0.1, 200);
	}

	cameraGroup.add(camera);
	camera.lookAt(origin);

	var renderer = new three_js.WebGLRenderer({ antialias: true });
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(width, height);
	renderer.setClearColor(0x000000, 1);
	container.appendChild(renderer.domElement);

	var lights = [];
	lights[0] = new three_js.PointLight(0xffffff, 1, 0);
	lights[1] = new three_js.PointLight(0xffffff, 1, 0);
	lights[2] = new three_js.PointLight(0xffffff, 1, 0);

	lights[0].position.set(0, 200, 0);
	lights[1].position.set(100, 200, 100);
	lights[2].position.set(-100, -200, -100);

	scene.add(lights[0]);
	scene.add(lights[1]);
	scene.add(lights[2]);

	var tetraTetra = new DualPair(new three_js.TetrahedronBufferGeometry(7), new three_js.TetrahedronBufferGeometry(7));

	var tetraGroup = new three_js.Group();
	tetraGroup.add(tetraTetra.group);

	if (width > height) {

		tetraGroup.rotation.x = Math.PI / 8;
		tetraGroup.position.x = -5;
		tetraGroup.position.y = 5;
		tetraTetra.setPosition(-14, 0, 5);
	} else {

		tetraGroup.rotation.x = Math.PI / 8;
		tetraGroup.position.x = -5;
		tetraGroup.position.y = 5;
		tetraTetra.setPosition(5, -24, 0);
	}

	tetraTetra.rotateDual(Math.PI / 2, 0, 0);
	//tetraTetra.addTo( scene );
	scene.add(tetraGroup);

	var cubeOcta = new DualPair(new three_js.BoxBufferGeometry(12, 12, 12), new three_js.OctahedronBufferGeometry(6));

	cubeOcta.setPosition(0, 0, 0);
	cubeOcta.rotatePrimary(Math.PI / 8, 0, 0);
	cubeOcta.rotateDual(Math.PI / 8, 0, 0);
	cubeOcta.addTo(scene);

	var dodecaIcosa = new DualPair(new three_js.DodecahedronBufferGeometry(8), new three_js.IcosahedronBufferGeometry(8));

	if (width > height) {

		dodecaIcosa.setPosition(19, 0, 0);
	} else {

		dodecaIcosa.setPosition(0, 19, 0);
	}

	dodecaIcosa.rotateDual(Math.PI / 2, 0, 0);
	dodecaIcosa.addTo(scene);

	var controlledObjectWrappers = [new objectControls.ControlledObjectWrapper(tetraTetra.group, 8, 0xffff7f), new objectControls.ControlledObjectWrapper(cubeOcta.group, 8, 0xffff7f), new objectControls.ControlledObjectWrapper(dodecaIcosa.group, 8, 0xffff7f)];

	var controlledObjects = controlledObjectWrappers.map(function (wrapper) {

		return wrapper.sphere;
	});

	var controlManager = new objectControls.ControlManager(camera, renderer.domElement, controlledObjects);
	var rotationControl = new objectControls.RotationControl();
	//rotationControl.addEventListener( 'change', render );

	controlManager.addMouseControl(objectControls.MOUSE_BUTTONS.LEFT, noflags, rotationControl);
	controlManager.addMouseControl(objectControls.MOUSE_BUTTONS.LEFT | objectControls.MOUSE_BUTTONS.RIGHT, noflags, rotationControl);
	controlManager.addMouseControl(objectControls.MOUSE_BUTTONS.LEFT, objectControls.ControlManager.shiftKey, rotationControl);
	controlManager.addTouchControl(1, noflags, rotationControl);

	var distanceMouseControl = new objectControls.DistanceMouseControl(camera);
	var distanceTouchControl = new objectControls.DistanceTouchControl(camera);
	var distanceWheelControl = new objectControls.DistanceWheelControl(camera);
	//distanceMouseControl.addEventListener( 'change', render );
	//distanceTouchControl.addEventListener( 'change', render );
	//distanceWheelControl.addEventListener( 'change', render );
	controlManager.addMouseControl(objectControls.MOUSE_BUTTONS.WHEEL, noflags, distanceMouseControl);
	controlManager.addTouchControl(2, noflags, distanceTouchControl);
	controlManager.addWheelControl(noflags, distanceWheelControl);

	var cameraDistanceControl = new objectControls.CameraDistanceControl(camera);
	controlManager.addMouseControl(objectControls.MOUSE_BUTTONS.WHEEL, objectControls.ControlManager.shiftKey, cameraDistanceControl);

	var directionControlMouse = new objectControls.DirectionControl(camera, renderer);
	//directionControl.addEventListener( 'change', render );
	controlManager.addMouseControl(objectControls.MOUSE_BUTTONS.RIGHT, noflags, directionControlMouse);
	controlManager.addMouseControl(objectControls.MOUSE_BUTTONS.LEFT | objectControls.MOUSE_BUTTONS.RIGHT, noflags, directionControlMouse);
	controlManager.addMouseControl(objectControls.MOUSE_BUTTONS.LEFT, objectControls.ControlManager.shiftKey, directionControlMouse);
	controlManager.addTouchControl(3, noflags, directionControlMouse);

	var cameraMoveControl = new objectControls.CameraMoveControl(camera, renderer);
	controlManager.addMouseControl(objectControls.MOUSE_BUTTONS.MIDDLE | objectControls.MOUSE_BUTTONS.RIGHT, noflags, cameraMoveControl);

	var cameraZoomControl = new objectControls.CameraZoomControl(camera, 0.1, 20);
	controlManager.addMouseControl(objectControls.MOUSE_BUTTONS.MIDDLE | objectControls.MOUSE_BUTTONS.LEFT, noflags, cameraZoomControl);

	var cameraRotationControl = new objectControls.CameraRotationControl(camera, renderer.domElement);
	controlManager.addMouseControl(objectControls.MOUSE_BUTTONS.MIDDLE | objectControls.MOUSE_BUTTONS.LEFT | objectControls.MOUSE_BUTTONS.RIGHT, noflags, cameraRotationControl);

	for (var idx = 0; idx < controlledObjectWrappers.length; idx++) {

		var wrapper = controlledObjectWrappers[idx];
		controlManager.addEventListener('start', wrapper.startListener, false);
		controlManager.addEventListener('end', wrapper.endListener, false);
	}

	var tcos = Math.cos(2 * Math.PI / 3);

	animate();

	function scaleAll() {

		var elapsedTime = clock.getElapsedTime();
		var cosTime1 = Math.cos(elapsedTime / 2);
		var cosTime2 = Math.cos(3 * elapsedTime / (2 * Math.PI));
		var cosTime3 = Math.cos(Math.E * elapsedTime / (2 * Math.PI));

		var tscalePrimary = (1 + tcos) * (1 + cosTime1) - tcos;
		var tscaleDual = (1 + tcos) * (1 - cosTime1) - tcos;
		tetraTetra.setScale(tscalePrimary, tscaleDual);

		var coScalePrimary = (1 / Math.sqrt(3) - 1) * (1 - cosTime2) / 2 + 1;
		var coScaleDual = (Math.sqrt(3) - 1) * (1 - cosTime2) / 2 + 1;
		cubeOcta.setScale(coScalePrimary, coScaleDual);
		dodecaIcosa.setScale(1 + cosTime3 / 8, 1 - cosTime3 / 8);
	}

	var animating = false;
	function animate() {

		if (!document.hidden) {

			scaleAll();
			render();
			requestAnimationFrame(animate);
		} else {

			animating = false;
		}
	}

	function render() {

		renderer.render(scene, camera);
	}

	document.addEventListener('visibilitychange', function () {

		if (!document.hidden && !animating) {

			animating = true;
			animate();
		}
	}, false);

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize(window.innerWidth, window.innerHeight);
	}

	window.addEventListener('resize', onWindowResize);
}

if (Detector.webgl) {

	window.onload = init;
} else {

	window.onload = function () {

		var warning = Detector.getWebGLErrorMessage();
		document.getElementById('webgl').appendChild(warning);
	};
}

document.addEventListener('contextmenu', function (e) {

	e.preventDefault();
});

}(THREE,Detector,OCONTROLS));
